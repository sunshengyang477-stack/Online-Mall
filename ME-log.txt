Android Online-Mall系统关键代码的心理执行

===================== 一、用户登录注册（SQLite） =====================

UserDBHelper.java

public class UserDBHelper extends SQLiteOpenHelper { private static
final String DB_NAME = “shop.db”; private static final int DB_VERSION =
4;

    public UserDBHelper(Context context) {
        super(context, DB_NAME, null, DB_VERSION);
    }

    @Override
    public void onCreate(SQLiteDatabase db) {
        db.execSQL("CREATE TABLE user(id INTEGER PRIMARY KEY AUTOINCREMENT, username TEXT UNIQUE, password TEXT)");
        db.execSQL("CREATE TABLE goods(id INTEGER PRIMARY KEY AUTOINCREMENT, name TEXT, price REAL, image INTEGER, description TEXT)");
        db.execSQL("CREATE TABLE cart(id INTEGER PRIMARY KEY AUTOINCREMENT, goods_id INTEGER, name TEXT, price REAL, image INTEGER, count INTEGER)");
        db.execSQL("CREATE TABLE orders(id INTEGER PRIMARY KEY AUTOINCREMENT, total REAL, time TEXT)");
        db.execSQL("CREATE TABLE order_item(id INTEGER PRIMARY KEY AUTOINCREMENT, order_id INTEGER, name TEXT, price REAL, count INTEGER)");
    }

    @Override
    public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
        db.execSQL("DROP TABLE IF EXISTS user");
        db.execSQL("DROP TABLE IF EXISTS goods");
        db.execSQL("DROP TABLE IF EXISTS cart");
        db.execSQL("DROP TABLE IF EXISTS orders");
        db.execSQL("DROP TABLE IF EXISTS order_item");
        onCreate(db);
    }

}
该代码负责整个线上购物系统本地 SQLite 数据库的创建与版本管理，在应用首次运行时统一创建用户表、商品表、购物车表、订单表及订单明细表，为后续所有业务功能提供数据持久化支持，数据库升级时通过删除旧表并重建新表来保证结构一致性，但该方式会导致历史数据丢失，若未提前做好数据迁移将产生严重业务副作用，同时在建表语句或升级过程中发生异常可能导致应用无法正常启动。
===================== 二、商品列表（RecyclerView） =====================

Goods.java

public class Goods { private int id; private String name; private double
price; private int imageResId; private String description; }
该代码用于封装商品的基本属性信息，将数据库中的商品记录抽象为对象以便在业务层和界面层之间传递数据，它本身不包含业务逻辑，但若字段设计不完整或类型不匹配将导致商品信息展示不全或运行时数据错误。
GoodsDao.java

public List getAllGoods() { List list = new ArrayList<>();
SQLiteDatabase db = dbHelper.getReadableDatabase(); Cursor c =
db.rawQuery(“SELECT * FROM goods”, null); while (c.moveToNext()) {
list.add(new Goods(c.getInt(0), c.getString(1), c.getDouble(2),
c.getInt(3), c.getString(4))); } c.close(); db.close(); return list; }
该代码负责从商品表中查询所有商品数据并转换为商品对象列表供界面展示，其核心业务逻辑是通过只读数据库连接和游标遍历实现数据读取，若游标或数据库未正确关闭可能引发内存泄露，若商品数据量过大且未分页查询则可能导致页面加载缓慢甚至界面卡顿。
===================== 三、商品详情页 =====================

GoodsDetailActivity.java

int goodsId = getIntent().getIntExtra(“goods_id”, -1); Goods goods =
goodsDao.getGoodsById(goodsId); btnAddCart.setOnClickListener(v ->
cartDao.addToCart(goods));
该代码通过接收上一个页面传递的商品标识加载对应商品详情，并在用户点击加入购物车按钮时将当前商品加入购物车，是商品浏览向交易行为过渡的关键节点，若商品标识未正确传递或为非法值将导致查询失败或空指针异常，从而影响用户正常操作流程。
===================== 四、购物车功能 =====================

CartDao.java

public void addToCart(Goods goods) { SQLiteDatabase db =
dbHelper.getWritableDatabase(); Cursor c = db.rawQuery(“SELECT count
FROM cart WHERE goods_id=?”, new
String[]{String.valueOf(goods.getId())}); if (c.moveToFirst()) {
db.execSQL(“UPDATE cart SET count=count+1 WHERE goods_id=?”, new
Object[]{goods.getId()}); } else { ContentValues v = new
ContentValues(); v.put(“goods_id”, goods.getId()); v.put(“name”,
goods.getName()); v.put(“price”, goods.getPrice()); v.put(“image”,
goods.getImageResId()); v.put(“count”, 1); db.insert(“cart”, null, v); }
c.close(); db.close(); }
该代码实现购物车添加商品的核心业务逻辑，通过先查询购物车中是否已存在对应商品决定是更新数量还是新增记录，从而避免同一商品重复出现，该设计提升了数据整洁性，但在数据库异常、并发操作或中途退出情况下可能导致商品数量不一致，若未对数据库操作结果进行校验还可能造成用户看到的购物车状态与真实数据不符。
===================== 五、订单结算 =====================

OrderDao.java

public boolean submitOrder(List cartList, double total) { SQLiteDatabase
db = dbHelper.getWritableDatabase(); db.beginTransaction(); try {
ContentValues order = new ContentValues(); order.put(“total”, total);
order.put(“time”, getCurrentTime()); long orderId = db.insert(“orders”,
null, order);

        for (CartItem item : cartList) {
            ContentValues v = new ContentValues();
            v.put("order_id", orderId);
            v.put("name", item.getName());
            v.put("price", item.getPrice());
            v.put("count", item.getCount());
            db.insert("order_item", null, v);
        }
        db.execSQL("DELETE FROM cart");
        db.setTransactionSuccessful();
        return true;
    } finally {
        db.endTransaction();
        db.close();
    }

}
该代码负责将购物车中的商品统一生成订单并写入订单主表与订单明细表，使用事务机制保证订单数据写入与购物车清空操作的原子性，避免出现部分成功的异常状态，但若事务过程中发生异常而未向用户明确反馈，将导致用户无法判断订单是否提交成功，同时未校验订单金额与购物车数据一致性可能引发业务逻辑错误。
===================== 六、订单列表 =====================

public List getOrderList() { List list = new ArrayList<>();
SQLiteDatabase db = dbHelper.getReadableDatabase(); Cursor c =
db.rawQuery(“SELECT * FROM orders ORDER BY id DESC”, null); while
(c.moveToNext()) { list.add(new Order(c.getInt(0), c.getDouble(1),
c.getString(2))); } c.close(); db.close(); return list; }
该代码用于按时间或编号倒序查询订单记录并生成订单对象列表，用于订单历史页面展示，其业务意义在于向用户提供可追溯的交易记录，但随着订单数据不断增长，若未引入分页或限制查询数量将对性能造成压力，严重时可能影响应用整体流畅度。
